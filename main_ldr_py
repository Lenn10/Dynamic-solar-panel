from machine import Pin, ADC, PWM
import time

# configure digital pins for multiplexer
pinS0 = Pin(2, Pin.OUT)
pinS1 = Pin(0, Pin.OUT)
pinS2 = Pin(4, Pin.OUT)

# configure analog pins for LDRs
pin0 = ADC(0)

# Define wait time between
# Definiert den zeitlichen Abstand zwischen den Nachregelungen, nachdem die Solarzelle optimal ausrichtet ist.
wait_control = 1

# Grenzwert analog definieren
# Definition des Grenzwerts für die LDR-Sensoren. Dieser definiert, wann der LDR im Schatten und wann in der Sonne ist.
limit = 200

# servos definieren
servo_drehung = PWM(Pin(12), freq=50)  # Pin2
servo_neigung = PWM(Pin(14), freq=50)  # Pin4
lim_servo_low = 25
lim_servo_up = 130
lim_2 = 99
mean_servo_bot = int(((lim_servo_up + lim_servo_low) / 2))
mean_servo_top = int((lim_servo_up + lim_2) / 2)
print(mean_servo_top)

#Grundstellung anfahren
servo_drehung.duty(mean_servo_bot)
servo_neigung.duty(mean_servo_top)


wait = 0.5

working_value_down = mean_servo_bot
working_value_up = mean_servo_top
delta = 3

# Alle LDR's auslesen und die Werte in Variablen abspeichern
while True:

    # LDR oben links lesen und speichern//Multiplexer A0
    time.sleep(wait)
    pinS0.value(0)
    pinS1.value(0)
    pinS2.value(0)
    value_top_left = pin0.read()  # Analogen Wert lesen
    top_left = value_top_left < limit
    print("0: " + str(value_top_left) + str(top_left))  # Analogen Wert in Konsole schreiben

    # LDR oben rechts lesen und speichern//Multiplexer A1
    time.sleep(wait)
    pinS0.value(1)
    pinS1.value(0)
    pinS2.value(0)
    value_top_right = pin0.read()
    top_right = value_top_right < limit
    print("1: " + str(value_top_right) + str(top_right))

    # LDR unten links lesen und speichern//Multiplexer A2
    time.sleep(wait)
    pinS0.value(0)
    pinS1.value(1)
    pinS2.value(0)
    value_bot_left = pin0.read()
    bot_left = value_bot_left < limit
    print("2: " + str(value_bot_left) + str(bot_left))

    # LDR unten rechts lesen und speichern//Multiplexer A3
    time.sleep(wait)
    pinS0.value(1)
    pinS1.value(1)
    pinS2.value(0)
    value_bot_right = pin0.read()
    bot_right = value_bot_right < limit
    print("3: " + str(value_bot_right) + str(bot_right))

    #Fallbestimmg und nachregelung der Servos
    # Fall1: Schatten trA1 + tlA0
    time.sleep(0)
    if top_right == True and top_left == True and bot_right == True and bot_left == True:
        print("Wolke")
        # time.sleep(3)#Pausenzeit falls wolke vorbeizieht, Zeit sollte dann af 10 min == 600 gestellt werden

    else:
        if top_right == True and top_left == True: #and working_value_up >= lim_servo_low:
            # servo Drehung um 1° in Uhrzeigersinn
            working_value_up = working_value_up - delta
            servo_neigung.duty(working_value_up)
            print("drehen")
        #   servo_neigung.duty(mittelstellung-1)# servo Neigung um 1° gegen Uhrzeigersinn

        # Fall2: Schatten tlA0 + blA2
        elif top_left == True and bot_left == True:# and working_value_up <= lim_servo_up:
            working_value_down = working_value_down + delta
            servo_drehung.duty(working_value_down)

         # servo Drehung um 1° gegen Uhrzeigersinn

        # Fall 3: Schatten trA1 +brA3
        elif top_right == True and bot_right == True:# and working_value_down <= lim_servo_up:
            # servo Drehung um 1° in Uhrzeigersinn
            working_value_down = working_value_down - delta
            servo_drehung.duty(working_value_down)

        # Fall 4: Schatten brA3 + blA2
        elif bot_right == True and bot_left == True:# and working_value_up >= lim_servo_low:
            # servo Drehung um 1° in Uhrzeigersinn
            working_value_up = working_value_up + delta
            servo_neigung.duty(working_value_up)

        else:
            # time.sleep(60)
            # Timer auf x sekunden, da kein LDR im Schatten ist und nicht nachgeregelt werden muss
            print("Keine Regelung notwendig" + str(working_value_up))

